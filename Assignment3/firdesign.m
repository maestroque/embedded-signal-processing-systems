%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 5LIK0 Embedded Signal Processing Systems
% Eindhoven University of Technology
% Author: Marc Geilen
%
% This script produces a low pass FIR filter 
% and generates C code for the filter coefficients
% in fixed-point representation
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% define the sampling frequency of 44.1kHz
fs = 44100; % do not change! Unless your stream uses a different sampling rate
% set the desired cut off frequency
fco = 500;
% compute the digital cut off frequency
wco = 2*pi*fco/fs;

% the FIR filter order
% you can modify this parameter to get a longer or shorter
% filter; a longer filter is typically better, but takes
% more time to compute
% Note that the *length* of the filter (the number of filter
% coefficients) will be N+1
N = 103;

% compute the FIR filter coefficients for a low pass filter 
b = fir1(N, wco/pi, 'low');

% make a plot of the frequency response of the 
% computed filter in dB
% freqz(b,1,512);
w = linspace(0,pi,512);
H = abs(b * exp(1i * w .* (0:N)'));


stable = true;
for w_i = linspace(0.8*pi, pi, 1000)
    if 20*log10(abs(b * exp(1i * w_i * (0:N)'))) > 20*log10(3e-3)
        stable = false;
        break;
    end
end

assert(stable == true, 'The filter is not stable');

% Calculate Q-factor
id_h = find(w >= wco);
id_l = find(w <= wco);
id_co = find(w >= wco, 1, "first");
H_h = H(id_h);
H_l = H(id_l);
id_min = find(H_h < 0.1, 1, 'first') + id_co - 1;
id_max = find(H_l > 0.8, 1, 'last');
Q = w(id_max) / w(id_min);

% Print Q-factor
fprintf('The Q-factor of the filter is: %f\n', Q);
fprintf('Omega_max: %f\n', w(id_max));
fprintf('Omega_min: %f\n', w(id_min));

figure;
hold on;
% plot(linspace(0,pi,512),20*log10(abs(H)));
plot(w, 20*log10(H))
yline(20*log10(4e-3), '--');
xlabel('Frequency (\omega)');
ylabel('Magnitude (dB)');
title('Frequency response of the FIR filter');
title(['Frequency response of the FIR filter (N = ', num2str(N), ')']);
grid on;
ylim([-80, 0]);
xlim([0, pi]);
xline(w(id_min), '--', 'Label', '\omega_2 : H(\omega) < 0.1');
xline(w(id_max), '--', 'Label', '\omega_1 : H(\omega) > 0.8');

% Add red highlighted area for omega between 0.8pi and pi
hold on;
x = linspace(0, pi, 512);
y = 20*log10(abs(H));
highlight_area = x >= 0.8*pi & x <= pi;
area(x(highlight_area), y(highlight_area), 'FaceColor', 'red', 'FaceAlpha', 0.3);
hold off;
saveas(gcf, 'frequency_response_dB.png');



% you can use the following equations to compute
% the frequency response for certain frequencies
% f0 = fs / 2; % response at highest frequency (half the sampling frequency)
% f1 = fco - 150;
% f2 = fco + 150;
% f3 = fco;
% w0 = 2*pi*f0/fs;
% w1 = 2*pi*f1/fs;
% w2 = 2*pi*f2/fs;
% w3 = 2*pi*f3/fs;
% r0 = b * exp(1i * w0 * (0:N)');
% r1 = b * exp(1i * w1 * (0:N)');
% r2 = b * exp(1i * w2 * (0:N)');
% r3 = b * exp(1i * w3 * (0:N)');
% fprintf('The response at frequency %f Hz is: %f\n', f0, abs(r0));
% fprintf('The response at frequency %f Hz is: %f\n', f1, abs(r1));
% fprintf('The response at frequency %f Hz is: %f\n', f2, abs(r2));
% fprintf('The response at frequency %f Hz is: %f\n', f3, abs(r3));

% make a plot of the frequency response with absolute 
% frequencies on the horizontal axis
w = 0:0.01:pi;
f = w / 2 / pi * fs;
r = exp(1i * w' * (0:N)) * b';
r_abs = abs(r);
figure;
plot(f, r_abs);
xlabel('Frequency (Hz)');
ylabel('Magnitude');
title('Frequency response of the FIR filter');
grid on;
saveas(gcf, 'frequency_response.png');

bitwidth = 16;
fractional_lengths = 1:1:30
Mean_abs_error = zeros(1,30)
for n = 1:30  
   bfixpt = fi(b, true, bitwidth,n);
   rfixpt = exp(1i * w' * (0:N)) * bfixpt';
   rfixpt_abs = abs(rfixpt);
   Mean_abs_error(n) = mean(abs(rfixpt_abs- r_abs))
end

figure;
plot(fractional_lengths, Mean_abs_error);
xlabel('Fractional length');
ylabel('Mean absolute error');
title('finding K');
grid on;


% convert the (floating point) filter coefficients to
% fixed point representation Q(16,8)
% you may decide te modify the fixed point representation,
% but be aware that the result cannot exceed 16 bit width,
% because they will be stored in Int16 type
% the result must be signed.
bitwidth = 16;       % do not change!
fractionlength = 8;  % you may change this value
bfixpt = fi(b, true, bitwidth, fractionlength);



% the remainder of the script writes a file called
% 'code_fragment.txt' that contains a piece of C code
% that defines a static array of 16 bit integers with 
% the FIR coefficients computed in this script.
% the code can be included in the filtercoefficient.h 
% source file.
cfile = fopen('code_fragment.txt','w');
fprintf(cfile, '// The code below is automatically generated by the Matlab script firdesign.m\n');
fprintf(cfile, '// It is an %dth order (length %d) low pass FIR filter with cutoff frequency %dHz.\n', N, N+1, round(fco));
fprintf(cfile, '// It is for a digital system with a sampling frequency of  %.1fkHz.\n', round(fs/1000,1));
fprintf(cfile, '// The generated filter coefficients are the integer representations of fixed point\n');
fprintf(cfile, '// numbers in the representation: Q(%d,%d).\n', bitwidth, fractionlength);
fprintf(cfile, '#define FIR_FILTER_LENGTH %d\n', N+1);
fprintf(cfile, '#define FIR_FRACTIONAL_BITS %d\n', fractionlength);
fprintf(cfile, 'const int16_t FIRFilterCoefficients[FIR_FILTER_LENGTH] = {\n\t');
for k = 1 : N+1
    fprintf(cfile, '%d', storedInteger(bfixpt(k)));
    if (k<N+1) 
        fprintf(cfile, ', ');
    end
    if (mod(k,8) == 0) 
        fprintf(cfile, '\n\t');
    end
end
fprintf(cfile, '\n};\n');

